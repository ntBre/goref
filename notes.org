* TODOS
** TODO add readme
** TODO start documentation
** TODO command line args  
    - h : help ; flags.PrintDefaults? only prints the flag info
    - s : search or q : query
    - c : alternate config file
** TODO Config file
*** TODO parser for this - minimal
    - path to library
    - path to refs.bib
    - pdf viewer
** TODO open match in pdf
   - search library path for matching name and open
** TODO work on TUI
   - go build . && st -e ./goref
     - seems like a good way to test
** TODO let SearchString take list of fields to show
** TODO handle resources like books, incollection, etc
*** TODO only print the fields that exist/are relevant
   - reading in works for the article fields
   - need to add their respective fields
   - also string type doesn't really work right now
** TODO continue adding test cases from problems in whole refs.bib
** TODO testing of add/edit methods
   - maybe the interface will handle the interesting parts

* Goal Features
  - TUI for adding, editing references, probably either
    - https://github.com/marcusolsson/tui-go
    - https://github.com/rivo/tview <- prob this one
  - Tagging system, cite by tag
    - ex) tag LYP86, LYP88, and B3 with :b3lyp: tag, :cite b3lyp -> \cite{LYP86, LYP88, B3}
  - Fuzzy find on all fields
    - ex) /for11dipole matches Fortenberry11dbs

* Ideas/notes
  - check for duplicate keys, everything else is probably okay not unique
  - might want to join the whole reference on one line to avoid line break stuff
    - should also help with fuzzy finding if I already have this mechanism
  - need to make curly braces optional in reading
    - separate read initial and normal read since after init they should be written by me?
    - take into account other possible delimiters like quotes
    - could just be opinionated about how the initial refs should be laid out
  - Add/edit methods for all fields of ref - not sure I need remove
  - maybe make regexes a loop too, hopefully
    - let the fields of references be keys with regex and a value
    - alternatively, let Value be a function that returns the right type or something
      #+BEGIN_SRC go
	type Key struct {
		Expr *regexp.Regexp
		Value interface{}
	}
	regexes := []*regexp.Regexp{...}
	for _, regex := range regexes {
      #+END_SRC


* Done
** DONE relax input reading constraints -> adjust regex, \s* for newlines, just look for end brace
   - case insensitive
** DONE fzf integration
   - have SearchString so just need to pipe them in
** DONE Work on WriteFZFList
   - works with full reference, but probably want to search by particular fields
   - checkboxes in interface to select fields
   - this will be useful even while nothing else works
   - just pipe this file into fzf and have most of the functionality I want
